---
title: R graphics magic that you should never use
---
I've been making graphics in R for quite a while

I've spent years of my life trying to make nice plots with base R
graphics. I've learned a bunch of tricks along the way, so now I'm
going to show you my vague boilerplate for bar plots, strip charts
and more complicated plots.

## Data
I'm going to use data came from an earlier version of
[this website](http://peregrinossantiago.es/eng/pilgrims-office/statistics/).
They're "statistics about pilgrims who have arrived in Santiago".
The observations are monthly, but I'm missing the Novembers and Decembers.

```r
pilgrams <- sqldf('select * from pilgram', dbname = 'pilgrams-db.sqlite')
```

I'm also going to use data from a
[wellbeing study](https://data.somervillema.gov/dataset/Results-of-2011-Wellbeing-Study/pjhx-dusc)
about Somerville, Massachusetts. There are a lot of missing values in this dataset, and I'm only
trying to show you how to make plots, so I'm just going to remove the missing values.

```r
wellbeing <- na.omit(read.csv('http://data.somervillema.gov/api/views/pjhx-dusc/rows.csv?accessType=DOWNLOAD'))
```

## One factor
Maybe we want count the marital statuses of Somerville residents.
This won't work.

    barplot(wellbeing$X24..What.is.your.marital.status.)

Instead, you need to give barplot a vector of heights. We can make one with `table`.

```{r barplot-
barplot(table(wellbeing$X24..What.is.your.marital.status.))
```

I can't read the bar labels, so let's make the bars horizontal.

```{r barplot-
barplot(table(wellbeing$X24..What.is.your.marital.status.), horiz = TRUE)
```

Oops. Now the labels are rotated the wrong way. The `las` parameter to `par` handles that.

```{r barplot-
barplot(table(wellbeing$X24..What.is.your.marital.status.), horiz = TRUE, las = 1)
```

And let's adjust the margin and bar labels so the text doesn't fall off.

```{r barplot-
levels(wellbeing$X24..What.is.your.marital.status.)[3] <- "Living with a partner\nbut not married"
par(mar = c(5, 12, 4, 2))
barplot(table(wellbeing$X24..What.is.your.marital.status.), horiz = TRUE, las = 1)
```

I also want to sort the bars so they're easier to read.

```{r barplot-
barplot(sort(table(wellbeing$X24..What.is.your.marital.status.), decreasing = TRUE), horiz = TRUE, las = 1)
```

The black border around the bars is noisy; let's remove it.

```{r barplot-
barplot(
  sort(table(wellbeing$X24..What.is.your.marital.status.), decreasing = TRUE),
  horiz = TRUE, las = 1, border = NA
)
```

Now the colors don't match. We could just make the bars black,

```{r barplot-
barplot(
  sort(table(wellbeing$X24..What.is.your.marital.status.), decreasing = TRUE),
  horiz = TRUE, las = 1, border = NA, col = 1
)
```

but that's a bit harsh. Instead, let's make everything grey.

```{r barplot-
barplot(
  sort(table(wellbeing$X24..What.is.your.marital.status.), decreasing = TRUE),
  horiz = TRUE, las = 1, border = NA, col = '#666666', fg = '#333333', col.axis = '#333333'
)
```

And add a title, of course

```{r barplot-
barplot(
  sort(table(wellbeing$X24..What.is.your.marital.status.), decreasing = TRUE),
  horiz = TRUE, las = 1, border = NA, col = '#666666', fg = '#333333', col.axis = '#333333',
  xlab = 'Number of residents',
  main = 'Marital statuses of Somerville residents'
)
```

The above call is boilerplate to me; in order to have any chance at making
any vaguely decent bar plot, you **minimally** need to adjust all of those parameters.
Summing that up, this is what I think the default barplot function should be.

```{r barplot-tom}
tom.barplot <- function(height, col = 'grey', border = NA, ...) {
  barplot(
    sort(table(height)), col = col, border = border,
    col = '#666666', fg = '#333333', col.axis = '#333333',
    ...
  )
}
```

## One factor and one numeric
A stripchart is sort of like a histogram, but it doesn't bin the observations.
Here is how people in Somerville are feeling, on a range of 1 to 10.

```{r stripchart-
stripchart(wellbeing$X1...First.of.all..how.happy.do.you.feel.right.now.., method = 'jitter')
```

We can also stack the observations

```{r stripchart-
stripchart(wellbeing$X1...First.of.all..how.happy.do.you.feel.right.now.., method = 'stack')
```

Let's change the scale to emphasize its limits.

```{r stripchart-
stripchart(wellbeing$X1...First.of.all..how.happy.do.you.feel.right.now..,
  method = 'stack', xlim = c(1:10)
)
```

The white boxes with borders are noisy; let's change them to filled boxes.
The default point type (`pch = 1`) doesn't support a fill color (`bg`),
so we have to switch to a different point type.

```{r stripchart-
stripchart(wellbeing$X1...First.of.all..how.happy.do.you.feel.right.now..,
  method = 'stack', xlim = c(1:10), col = NA, pch = 22, bg = 1
)
```

You can see all of the pch types here.

```{r stripchart-pch}
pchShow()
```

Now we could also color the points by a different color depending on the
gender.

```{r stripchart-
stripchart(wellbeing$X1...First.of.all..how.happy.do.you.feel.right.now..,
  method = 'stack', xlim = c(1:10), col = NA, pch = 22, bg = 3 + wellbeing$X15..Gender..1..female..2..male.
)
legend('topleft', c('Female', 'Male'), col = NA, pch = 22, pt.bg = 4:5
```

Like I said before for `barplot`, you should see this `stripchart` command
as the boilerplate for making strip charts. Like `barplot`, `stripchart` is
quite ugly until you set all of these parameters.

## par
All of these `col`, `pch`, `bg`, `fg`, `border`, &c. commands are graphical
parameters passed to `par`. You can set their global defaults with `par`,
but they won't necessarily apply to the same scope as when you pass them
within a function. For example, `bg` applies to the outer canvas's background.

```{r par-
par(bg = 'yellow')
plot(Total ~ id, data = pilgrams, type = 'l')
```

You might use this to set fonts across all of your plots.

```{r 
par(family = 'serif', font = 3, font.lab = 3, font.main = 2, font.sub = 3)
plot(Total ~ id, data = pilgrams, type = 'l', main = 'Pilgrams')
```

I tend to find the global namespace unpleasant, so I like to wrap that
in a function that closes the device afterwards, with `dev.off`.
(The settings only apply to the current device.)

    plot.something <- function(a, b, c, e, f) {
      par(family = 'serif', font = 3, font.lab = 3, font.main = 2, font.sub = 3)
      plot(a ~ b, col = c)
      lines(d, e)
      # ...
      dev.off()
    }

`mfrow` and `mfcol` allow you to make multiple plots in one device

```{r par-
par(mfrow = c(2,2))
plot(lm(Men ~ Women, data = pilgrams), mfrow = c(2,2))
```

`bty` lets you change the outer border of the plot.

```{r par-
plot(Total ~ id, data = pilgrams, type = 'l', bty = 'l')
```

Its options are quite hilarious; here is its entry in `?par`.

    ‘bty’ A character string which determined the type of ‘box’ which
         is drawn about plots.  If ‘bty’ is one of ‘"o"’ (the
         default), ‘"l"’, ‘"7"’, ‘"c"’, ‘"u"’, or ‘"]"’ the resulting
         box resembles the corresponding upper case letter.  A value
         of ‘"n"’ suppresses the box.

Most plotting commands call `plot.new`, which clears the plot by
default. Setting `new` to `TRUE` makes it not clear the plot, which
can help you build up more complicated plots.


## Complicated plots
Displaying multiple sets of lines and points on a graph gets more messy.
For example, let's say we want to make two lines to represent pilgram
counts. One is for people on horseback, and the other is for people on
foot. First, I like to make an empty plot with the full range so we don't
cut anything off. Let's also put the labels and remove the axes.

```{r complicated-
plot(0,0,
  xlim = range(pilgrams$id),
  ylim = c(0,max(c(pilgrams$Foot, pilgrams$Bicicle))),
  xlab = 'Month',
  ylab = 'Number of pilgrams',
  main = 'Pilgrams by month and transportation medium',
  axes = FALSE,
  type = 'n'
)
```

The key there is `type = 'n'`, which makes no data be plotted.
Now we can add the lines one at a time.

```{r complicated-
lines(Foot ~ id, data = pilgrams, lty = 1)
lines(Bicicle ~ id, data = pilgrams, lty = 2)
legend('topleft', c('Foot', 'Bicycle'), title = 'Transportation media', lty = 1:2)
```

I removed the axes because the default axes are usually quite
ugly. Now let's add prettier axes.

```{r complicated-
axis(1, at = seq(1, 80, 10), labels = paste('January', unique(pilgrams$year)))
par(las = 1)
axis(2, at = seq(0, 60000, 10000), labels = c(0, paste0(1:6, '0,000')))
```

The tick marks go at `at`, and they are labeled with `labels`.


The above dozen-or-so lines of code are approximately my boilerplate for simple
line plots. Partly, this is because I switched the default axis for calls to `axis`;
I usually do this with any plot, but I left it out of the earlier stripcharts and
bar plot. But the main reason for the increased size is that different levels/subsets
need to be plotted as separate calls.




## Conclusion
I just showed you some boilerplate bar plots, strip chart and
line plots, each involving a few lines of code to produce the plot
that I conceive as the default.

Learn from my mistakes! Don't learn base R graphics, unless you want
to make [music videos]().
ggplot has more reasonable supports and relates
different variables better (through the grammar of graphics), so all of
those boilerplate plots would have been one call to ggplot.
